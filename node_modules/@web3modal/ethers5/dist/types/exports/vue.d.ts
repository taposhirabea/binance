/// <reference types="node" />
import type { Web3ModalOptions } from '../src/client.js';
import { Web3Modal } from '../src/client.js';
export type { Web3ModalOptions } from '../src/client.js';
export declare function createWeb3Modal(options: Web3ModalOptions): Web3Modal;
export declare function useWeb3ModalSigner(): {
    walletProvider: import("vue").Ref<{
        readonly provider: {
            isMetaMask?: boolean | undefined;
            isStatus?: boolean | undefined;
            host?: string | undefined;
            path?: string | undefined;
            sendAsync?: ((request: {
                method: string;
                params?: any[] | undefined;
            }, callback: (error: any, response: any) => void) => void) | undefined;
            send?: ((request: {
                method: string;
                params?: any[] | undefined;
            }, callback: (error: any, response: any) => void) => void) | undefined;
            request?: ((request: {
                method: string;
                params?: any[] | undefined;
            }) => Promise<any>) | undefined;
        };
        readonly jsonRpcFetchFunc: import("@ethersproject/providers").JsonRpcFetchFunc;
        send: (method: string, params: any[]) => Promise<any>;
        readonly connection: {
            url: string;
            headers?: {
                [key: string]: string | number;
            } | undefined;
            user?: string | undefined;
            password?: string | undefined;
            allowInsecureAuthentication?: boolean | undefined;
            allowGzip?: boolean | undefined;
            throttleLimit?: number | undefined;
            throttleSlotInterval?: number | undefined;
            throttleCallback?: ((attempt: number, url: string) => Promise<boolean>) | undefined;
            skipFetchSetup?: boolean | undefined;
            fetchOptions?: Record<string, string> | undefined;
            errorPassThrough?: boolean | undefined;
            timeout?: number | undefined;
        };
        _pendingFilter: {
            then: <TResult1 = number, TResult2 = never>(onfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
            catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<number | TResult>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<number>;
            readonly [Symbol.toStringTag]: string;
        };
        _nextId: number;
        _eventLoopCache: Record<string, Promise<any>>;
        readonly _cache: Record<string, Promise<any>>;
        detectNetwork: () => Promise<import("@ethersproject/networks").Network>;
        _uncachedDetectNetwork: () => Promise<import("@ethersproject/networks").Network>;
        getSigner: (addressOrIndex?: string | number | undefined) => import("@ethersproject/providers").JsonRpcSigner;
        getUncheckedSigner: (addressOrIndex?: string | number | undefined) => {
            sendTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
            readonly provider: import("@ethersproject/providers").JsonRpcProvider;
            _index: number;
            _address: string;
            connect(provider: import("@ethersproject/abstract-provider").Provider): import("@ethersproject/providers").JsonRpcSigner;
            connectUnchecked(): import("@ethersproject/providers").JsonRpcSigner;
            getAddress(): Promise<string>;
            sendUncheckedTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<string>;
            signTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<string>;
            signMessage(message: string | import("ethers").Bytes): Promise<string>;
            _legacySignMessage(message: string | import("ethers").Bytes): Promise<string>;
            _signTypedData(domain: import("ethers").TypedDataDomain, types: Record<string, import("ethers").TypedDataField[]>, value: Record<string, any>): Promise<string>;
            unlock(password: string): Promise<boolean>;
            readonly _isSigner: boolean;
            getBalance(blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined): Promise<import("ethers").BigNumber>;
            getTransactionCount(blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined): Promise<number>;
            estimateGas(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<import("ethers").BigNumber>;
            call(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined): Promise<string>;
            getChainId(): Promise<number>;
            getGasPrice(): Promise<import("ethers").BigNumber>;
            getFeeData(): Promise<import("@ethersproject/abstract-provider").FeeData>;
            resolveName(name: string): Promise<string>;
            checkTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>;
            populateTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<import("@ethersproject/abstract-provider").TransactionRequest>;
            _checkProvider(operation?: string | undefined): void;
        };
        listAccounts: () => Promise<string[]>;
        prepareRequest: (method: string, params: any) => [string, any[]];
        perform: (method: string, params: any) => Promise<any>;
        _startEvent: (event: import("@ethersproject/providers/lib/base-provider.js").Event) => void;
        _startPending: () => void;
        _stopEvent: (event: import("@ethersproject/providers/lib/base-provider.js").Event) => void;
        _networkPromise: {
            then: <TResult1_1 = import("@ethersproject/networks").Network, TResult2_1 = never>(onfulfilled?: ((value: import("@ethersproject/networks").Network) => TResult1_1 | PromiseLike<TResult1_1>) | null | undefined, onrejected?: ((reason: any) => TResult2_1 | PromiseLike<TResult2_1>) | null | undefined) => Promise<TResult1_1 | TResult2_1>;
            catch: <TResult_1 = never>(onrejected?: ((reason: any) => TResult_1 | PromiseLike<TResult_1>) | null | undefined) => Promise<import("@ethersproject/networks").Network | TResult_1>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<import("@ethersproject/networks").Network>;
            readonly [Symbol.toStringTag]: string;
        };
        _network: {
            name: string;
            chainId: number;
            ensAddress?: string | undefined;
            _defaultProvider?: ((providers: any, options?: any) => any) | undefined;
        };
        _events: {
            readonly listener: import("@ethersproject/abstract-provider").Listener;
            readonly once: boolean;
            readonly tag: string;
            _lastBlockNumber: number;
            _inflight: boolean;
            readonly event: string | (string | string[])[] | {
                address?: string | undefined;
                topics?: (string | string[] | null)[] | undefined;
            } | {
                readonly expiry: number;
                readonly _isForkEvent?: boolean | undefined;
            };
            readonly type: string;
            readonly hash: string;
            readonly filter: {
                fromBlock?: import("@ethersproject/abstract-provider").BlockTag | undefined;
                toBlock?: import("@ethersproject/abstract-provider").BlockTag | undefined;
                address?: string | undefined;
                topics?: (string | string[] | null)[] | undefined;
            };
            pollable: () => boolean;
        }[];
        formatter: {
            readonly formats: {
                transaction: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                transactionRequest: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                receipt: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                receiptLog: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                block: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                blockWithTransactions: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                filter: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                filterLog: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
            };
            getDefaultFormats: () => import("@ethersproject/providers/lib/formatter.js").Formats;
            accessList: (accessList: any[]) => import("@ethersproject/transactions").AccessList;
            number: (number: any) => number;
            type: (number: any) => number;
            bigNumber: (value: any) => import("ethers").BigNumber;
            boolean: (value: any) => boolean;
            hex: (value: any, strict?: boolean | undefined) => string;
            data: (value: any, strict?: boolean | undefined) => string;
            address: (value: any) => string;
            callAddress: (value: any) => string;
            contractAddress: (value: any) => string;
            blockTag: (blockTag: any) => string;
            hash: (value: any, strict?: boolean | undefined) => string;
            difficulty: (value: any) => number;
            uint256: (value: any) => string;
            _block: (value: any, format: any) => import("@ethersproject/abstract-provider").Block;
            block: (value: any) => import("@ethersproject/abstract-provider").Block;
            blockWithTransactions: (value: any) => import("@ethersproject/abstract-provider").Block;
            transactionRequest: (value: any) => any;
            transactionResponse: (transaction: any) => import("@ethersproject/abstract-provider").TransactionResponse;
            transaction: (value: any) => any;
            receiptLog: (value: any) => any;
            receipt: (value: any) => import("@ethersproject/abstract-provider").TransactionReceipt;
            topics: (value: any) => any;
            filter: (value: any) => any;
            filterLog: (value: any) => any;
        };
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: {
            hasRef: () => boolean;
            refresh: () => NodeJS.Timer;
            [Symbol.toPrimitive]: () => number;
            ref: () => NodeJS.Timer;
            unref: () => NodeJS.Timer;
        };
        _bootstrapPoll: {
            hasRef: () => boolean;
            refresh: () => NodeJS.Timer;
            [Symbol.toPrimitive]: () => number;
            ref: () => NodeJS.Timer;
            unref: () => NodeJS.Timer;
        };
        _lastBlockNumber: number;
        _maxFilterBlockRange: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: {
            then: <TResult1 = number, TResult2 = never>(onfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
            catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<number | TResult>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<number>;
            readonly [Symbol.toStringTag]: string;
        };
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: {
            then: <TResult1_2 = {
                blockNumber: number;
                reqTime: number;
                respTime: number;
            }, TResult2_2 = never>(onfulfilled?: ((value: {
                blockNumber: number;
                reqTime: number;
                respTime: number;
            }) => TResult1_2 | PromiseLike<TResult1_2>) | null | undefined, onrejected?: ((reason: any) => TResult2_2 | PromiseLike<TResult2_2>) | null | undefined) => Promise<TResult1_2 | TResult2_2>;
            catch: <TResult_2 = never>(onrejected?: ((reason: any) => TResult_2 | PromiseLike<TResult_2>) | null | undefined) => Promise<{
                blockNumber: number;
                reqTime: number;
                respTime: number;
            } | TResult_2>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<{
                blockNumber: number;
                reqTime: number;
                respTime: number;
            }>;
            readonly [Symbol.toStringTag]: string;
        };
        readonly anyNetwork: boolean;
        disableCcipRead: boolean;
        _ready: () => Promise<import("@ethersproject/networks").Network>;
        readonly ready: {
            then: <TResult1_1 = import("@ethersproject/networks").Network, TResult2_1 = never>(onfulfilled?: ((value: import("@ethersproject/networks").Network) => TResult1_1 | PromiseLike<TResult1_1>) | null | undefined, onrejected?: ((reason: any) => TResult2_1 | PromiseLike<TResult2_1>) | null | undefined) => Promise<TResult1_1 | TResult2_1>;
            catch: <TResult_1 = never>(onrejected?: ((reason: any) => TResult_1 | PromiseLike<TResult_1>) | null | undefined) => Promise<import("@ethersproject/networks").Network | TResult_1>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<import("@ethersproject/networks").Network>;
            readonly [Symbol.toStringTag]: string;
        };
        ccipReadFetch: (tx: import("ethers").Transaction, calldata: string, urls: string[]) => Promise<string | null>;
        _getInternalBlockNumber: (maxAge: number) => Promise<number>;
        poll: () => Promise<void>;
        resetEventsBlock: (blockNumber: number) => void;
        readonly network: {
            name: string;
            chainId: number;
            ensAddress?: string | undefined;
            _defaultProvider?: ((providers: any, options?: any) => any) | undefined;
        };
        getNetwork: () => Promise<import("@ethersproject/networks").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber: () => Promise<number>;
        _setFastBlockNumber: (blockNumber: number) => void;
        waitForTransaction: (transactionHash: string, confirmations?: number | undefined, timeout?: number | undefined) => Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        _waitForTransaction: (transactionHash: string, confirmations: number, timeout: number, replaceable: {
            data: string;
            from: string;
            nonce: number;
            to: string;
            value: import("ethers").BigNumber;
            startBlock: number;
        }) => Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getBlockNumber: () => Promise<number>;
        getGasPrice: () => Promise<import("ethers").BigNumber>;
        getBalance: (addressOrName: string | Promise<string>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<import("ethers").BigNumber>;
        getTransactionCount: (addressOrName: string | Promise<string>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<number>;
        getCode: (addressOrName: string | Promise<string>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<string>;
        getStorageAt: (addressOrName: string | Promise<string>, position: import("ethers").BigNumberish | Promise<import("ethers").BigNumberish>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<string>;
        _wrapTransaction: (tx: import("ethers").Transaction, hash?: string | undefined, startBlock?: number | undefined) => import("@ethersproject/abstract-provider").TransactionResponse;
        sendTransaction: (signedTransaction: string | Promise<string>) => Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        _getTransactionRequest: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<import("ethers").Transaction>;
        _getFilter: (filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>) => Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        _call: (transaction: import("@ethersproject/abstract-provider").TransactionRequest, blockTag: import("@ethersproject/abstract-provider").BlockTag, attempt: number) => Promise<string>;
        call: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<string>;
        estimateGas: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<import("ethers").BigNumber>;
        _getAddress: (addressOrName: string | Promise<string>) => Promise<string>;
        _getBlock: (blockHashOrBlockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>, includeTransactions?: boolean | undefined) => Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getBlock: (blockHashOrBlockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>) => Promise<import("@ethersproject/abstract-provider").Block>;
        getBlockWithTransactions: (blockHashOrBlockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>) => Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getTransaction: (transactionHash: string | Promise<string>) => Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        getTransactionReceipt: (transactionHash: string | Promise<string>) => Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getLogs: (filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>) => Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice: () => Promise<number>;
        _getBlockTag: (blockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>) => Promise<import("@ethersproject/abstract-provider").BlockTag>;
        getResolver: (name: string) => Promise<import("@ethersproject/providers").Resolver | null>;
        _getResolver: (name: string, operation?: string | undefined) => Promise<string>;
        resolveName: (name: string | Promise<string>) => Promise<string | null>;
        lookupAddress: (address: string | Promise<string>) => Promise<string | null>;
        getAvatar: (nameOrAddress: string) => Promise<string | null>;
        _addEventListener: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean) => import("@ethersproject/providers").Web3Provider;
        on: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/providers").Web3Provider;
        once: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/providers").Web3Provider;
        emit: (eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]) => boolean;
        listenerCount: (eventName?: import("@ethersproject/abstract-provider").EventType | undefined) => number;
        listeners: (eventName?: import("@ethersproject/abstract-provider").EventType | undefined) => import("@ethersproject/abstract-provider").Listener[];
        off: (eventName: import("@ethersproject/abstract-provider").EventType, listener?: import("@ethersproject/abstract-provider").Listener | undefined) => import("@ethersproject/providers").Web3Provider;
        removeAllListeners: (eventName?: import("@ethersproject/abstract-provider").EventType | undefined) => import("@ethersproject/providers").Web3Provider;
        getFeeData: () => Promise<import("@ethersproject/abstract-provider").FeeData>;
        addListener: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/abstract-provider").Provider;
        removeListener: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/abstract-provider").Provider;
        readonly _isProvider: boolean;
    } | undefined>;
    walletProviderType: import("vue").Ref<"walletConnect" | "injected" | "coinbaseWallet" | "eip6963" | undefined>;
    signer: import("vue").Ref<{
        readonly provider: {
            readonly connection: {
                url: string;
                headers?: {
                    [key: string]: string | number;
                } | undefined;
                user?: string | undefined;
                password?: string | undefined;
                allowInsecureAuthentication?: boolean | undefined;
                allowGzip?: boolean | undefined;
                throttleLimit?: number | undefined;
                throttleSlotInterval?: number | undefined;
                throttleCallback?: ((attempt: number, url: string) => Promise<boolean>) | undefined;
                skipFetchSetup?: boolean | undefined;
                fetchOptions?: Record<string, string> | undefined;
                errorPassThrough?: boolean | undefined;
                timeout?: number | undefined;
            };
            _pendingFilter: {
                then: <TResult1 = number, TResult2 = never>(onfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
                catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<number | TResult>;
                finally: (onfinally?: (() => void) | null | undefined) => Promise<number>;
                readonly [Symbol.toStringTag]: string;
            };
            _nextId: number;
            _eventLoopCache: Record<string, Promise<any>>;
            readonly _cache: Record<string, Promise<any>>;
            detectNetwork: () => Promise<import("@ethersproject/networks").Network>;
            _uncachedDetectNetwork: () => Promise<import("@ethersproject/networks").Network>;
            getSigner: (addressOrIndex?: string | number | undefined) => import("@ethersproject/providers").JsonRpcSigner;
            getUncheckedSigner: (addressOrIndex?: string | number | undefined) => {
                sendTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
                readonly provider: import("@ethersproject/providers").JsonRpcProvider;
                _index: number;
                _address: string;
                connect(provider: import("@ethersproject/abstract-provider").Provider): import("@ethersproject/providers").JsonRpcSigner;
                connectUnchecked(): import("@ethersproject/providers").JsonRpcSigner;
                getAddress(): Promise<string>;
                sendUncheckedTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<string>;
                signTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<string>;
                signMessage(message: string | import("ethers").Bytes): Promise<string>;
                _legacySignMessage(message: string | import("ethers").Bytes): Promise<string>;
                _signTypedData(domain: import("ethers").TypedDataDomain, types: Record<string, import("ethers").TypedDataField[]>, value: Record<string, any>): Promise<string>;
                unlock(password: string): Promise<boolean>;
                readonly _isSigner: boolean;
                getBalance(blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined): Promise<import("ethers").BigNumber>;
                getTransactionCount(blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined): Promise<number>;
                estimateGas(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<import("ethers").BigNumber>;
                call(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined): Promise<string>;
                getChainId(): Promise<number>;
                getGasPrice(): Promise<import("ethers").BigNumber>;
                getFeeData(): Promise<import("@ethersproject/abstract-provider").FeeData>;
                resolveName(name: string): Promise<string>;
                checkTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>;
                populateTransaction(transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>): Promise<import("@ethersproject/abstract-provider").TransactionRequest>;
                _checkProvider(operation?: string | undefined): void;
            };
            listAccounts: () => Promise<string[]>;
            send: (method: string, params: any[]) => Promise<any>;
            prepareRequest: (method: string, params: any) => [string, any[]];
            perform: (method: string, params: any) => Promise<any>;
            _startEvent: (event: import("@ethersproject/providers/lib/base-provider.js").Event) => void;
            _startPending: () => void;
            _stopEvent: (event: import("@ethersproject/providers/lib/base-provider.js").Event) => void;
            _networkPromise: {
                then: <TResult1_1 = import("@ethersproject/networks").Network, TResult2_1 = never>(onfulfilled?: ((value: import("@ethersproject/networks").Network) => TResult1_1 | PromiseLike<TResult1_1>) | null | undefined, onrejected?: ((reason: any) => TResult2_1 | PromiseLike<TResult2_1>) | null | undefined) => Promise<TResult1_1 | TResult2_1>;
                catch: <TResult_1 = never>(onrejected?: ((reason: any) => TResult_1 | PromiseLike<TResult_1>) | null | undefined) => Promise<import("@ethersproject/networks").Network | TResult_1>;
                finally: (onfinally?: (() => void) | null | undefined) => Promise<import("@ethersproject/networks").Network>;
                readonly [Symbol.toStringTag]: string;
            };
            _network: {
                name: string;
                chainId: number;
                ensAddress?: string | undefined;
                _defaultProvider?: ((providers: any, options?: any) => any) | undefined;
            };
            _events: {
                readonly listener: import("@ethersproject/abstract-provider").Listener;
                readonly once: boolean;
                readonly tag: string;
                _lastBlockNumber: number;
                _inflight: boolean;
                readonly event: string | (string | string[])[] | {
                    address?: string | undefined;
                    topics?: (string | string[] | null)[] | undefined;
                } | {
                    readonly expiry: number;
                    readonly _isForkEvent?: boolean | undefined;
                };
                readonly type: string;
                readonly hash: string;
                readonly filter: {
                    fromBlock?: import("@ethersproject/abstract-provider").BlockTag | undefined;
                    toBlock?: import("@ethersproject/abstract-provider").BlockTag | undefined;
                    address?: string | undefined;
                    topics?: (string | string[] | null)[] | undefined;
                };
                pollable: () => boolean;
            }[];
            formatter: {
                readonly formats: {
                    transaction: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                    transactionRequest: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                    receipt: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                    receiptLog: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                    block: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                    blockWithTransactions: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                    filter: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                    filterLog: import("@ethersproject/providers/lib/formatter.js").FormatFuncs;
                };
                getDefaultFormats: () => import("@ethersproject/providers/lib/formatter.js").Formats;
                accessList: (accessList: any[]) => import("@ethersproject/transactions").AccessList;
                number: (number: any) => number;
                type: (number: any) => number;
                bigNumber: (value: any) => import("ethers").BigNumber;
                boolean: (value: any) => boolean;
                hex: (value: any, strict?: boolean | undefined) => string;
                data: (value: any, strict?: boolean | undefined) => string;
                address: (value: any) => string;
                callAddress: (value: any) => string;
                contractAddress: (value: any) => string;
                blockTag: (blockTag: any) => string;
                hash: (value: any, strict?: boolean | undefined) => string;
                difficulty: (value: any) => number;
                uint256: (value: any) => string;
                _block: (value: any, format: any) => import("@ethersproject/abstract-provider").Block;
                block: (value: any) => import("@ethersproject/abstract-provider").Block;
                blockWithTransactions: (value: any) => import("@ethersproject/abstract-provider").Block;
                transactionRequest: (value: any) => any;
                transactionResponse: (transaction: any) => import("@ethersproject/abstract-provider").TransactionResponse;
                transaction: (value: any) => any;
                receiptLog: (value: any) => any;
                receipt: (value: any) => import("@ethersproject/abstract-provider").TransactionReceipt;
                topics: (value: any) => any;
                filter: (value: any) => any;
                filterLog: (value: any) => any;
            };
            _emitted: {
                [eventName: string]: number | "pending";
            };
            _pollingInterval: number;
            _poller: {
                hasRef: () => boolean;
                refresh: () => NodeJS.Timer;
                [Symbol.toPrimitive]: () => number;
                ref: () => NodeJS.Timer;
                unref: () => NodeJS.Timer;
            };
            _bootstrapPoll: {
                hasRef: () => boolean;
                refresh: () => NodeJS.Timer;
                [Symbol.toPrimitive]: () => number;
                ref: () => NodeJS.Timer;
                unref: () => NodeJS.Timer;
            };
            _lastBlockNumber: number;
            _maxFilterBlockRange: number;
            _fastBlockNumber: number;
            _fastBlockNumberPromise: {
                then: <TResult1 = number, TResult2 = never>(onfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
                catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<number | TResult>;
                finally: (onfinally?: (() => void) | null | undefined) => Promise<number>;
                readonly [Symbol.toStringTag]: string;
            };
            _fastQueryDate: number;
            _maxInternalBlockNumber: number;
            _internalBlockNumber: {
                then: <TResult1_2 = {
                    blockNumber: number;
                    reqTime: number;
                    respTime: number;
                }, TResult2_2 = never>(onfulfilled?: ((value: {
                    blockNumber: number;
                    reqTime: number;
                    respTime: number;
                }) => TResult1_2 | PromiseLike<TResult1_2>) | null | undefined, onrejected?: ((reason: any) => TResult2_2 | PromiseLike<TResult2_2>) | null | undefined) => Promise<TResult1_2 | TResult2_2>;
                catch: <TResult_2 = never>(onrejected?: ((reason: any) => TResult_2 | PromiseLike<TResult_2>) | null | undefined) => Promise<{
                    blockNumber: number;
                    reqTime: number;
                    respTime: number;
                } | TResult_2>;
                finally: (onfinally?: (() => void) | null | undefined) => Promise<{
                    blockNumber: number;
                    reqTime: number;
                    respTime: number;
                }>;
                readonly [Symbol.toStringTag]: string;
            };
            readonly anyNetwork: boolean;
            disableCcipRead: boolean;
            _ready: () => Promise<import("@ethersproject/networks").Network>;
            readonly ready: {
                then: <TResult1_1 = import("@ethersproject/networks").Network, TResult2_1 = never>(onfulfilled?: ((value: import("@ethersproject/networks").Network) => TResult1_1 | PromiseLike<TResult1_1>) | null | undefined, onrejected?: ((reason: any) => TResult2_1 | PromiseLike<TResult2_1>) | null | undefined) => Promise<TResult1_1 | TResult2_1>;
                catch: <TResult_1 = never>(onrejected?: ((reason: any) => TResult_1 | PromiseLike<TResult_1>) | null | undefined) => Promise<import("@ethersproject/networks").Network | TResult_1>;
                finally: (onfinally?: (() => void) | null | undefined) => Promise<import("@ethersproject/networks").Network>;
                readonly [Symbol.toStringTag]: string;
            };
            ccipReadFetch: (tx: import("ethers").Transaction, calldata: string, urls: string[]) => Promise<string | null>;
            _getInternalBlockNumber: (maxAge: number) => Promise<number>;
            poll: () => Promise<void>;
            resetEventsBlock: (blockNumber: number) => void;
            readonly network: {
                name: string;
                chainId: number;
                ensAddress?: string | undefined;
                _defaultProvider?: ((providers: any, options?: any) => any) | undefined;
            };
            getNetwork: () => Promise<import("@ethersproject/networks").Network>;
            readonly blockNumber: number;
            polling: boolean;
            pollingInterval: number;
            _getFastBlockNumber: () => Promise<number>;
            _setFastBlockNumber: (blockNumber: number) => void;
            waitForTransaction: (transactionHash: string, confirmations?: number | undefined, timeout?: number | undefined) => Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
            _waitForTransaction: (transactionHash: string, confirmations: number, timeout: number, replaceable: {
                data: string;
                from: string;
                nonce: number;
                to: string;
                value: import("ethers").BigNumber;
                startBlock: number;
            }) => Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
            getBlockNumber: () => Promise<number>;
            getGasPrice: () => Promise<import("ethers").BigNumber>;
            getBalance: (addressOrName: string | Promise<string>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<import("ethers").BigNumber>;
            getTransactionCount: (addressOrName: string | Promise<string>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<number>;
            getCode: (addressOrName: string | Promise<string>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<string>;
            getStorageAt: (addressOrName: string | Promise<string>, position: import("ethers").BigNumberish | Promise<import("ethers").BigNumberish>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<string>;
            _wrapTransaction: (tx: import("ethers").Transaction, hash?: string | undefined, startBlock?: number | undefined) => import("@ethersproject/abstract-provider").TransactionResponse;
            sendTransaction: (signedTransaction: string | Promise<string>) => Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
            _getTransactionRequest: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<import("ethers").Transaction>;
            _getFilter: (filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>) => Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
            _call: (transaction: import("@ethersproject/abstract-provider").TransactionRequest, blockTag: import("@ethersproject/abstract-provider").BlockTag, attempt: number) => Promise<string>;
            call: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag> | undefined) => Promise<string>;
            estimateGas: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<import("ethers").BigNumber>;
            _getAddress: (addressOrName: string | Promise<string>) => Promise<string>;
            _getBlock: (blockHashOrBlockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>, includeTransactions?: boolean | undefined) => Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
            getBlock: (blockHashOrBlockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>) => Promise<import("@ethersproject/abstract-provider").Block>;
            getBlockWithTransactions: (blockHashOrBlockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>) => Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
            getTransaction: (transactionHash: string | Promise<string>) => Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
            getTransactionReceipt: (transactionHash: string | Promise<string>) => Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
            getLogs: (filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>) => Promise<import("@ethersproject/abstract-provider").Log[]>;
            getEtherPrice: () => Promise<number>;
            _getBlockTag: (blockTag: import("@ethersproject/abstract-provider").BlockTag | Promise<import("@ethersproject/abstract-provider").BlockTag>) => Promise<import("@ethersproject/abstract-provider").BlockTag>;
            getResolver: (name: string) => Promise<import("@ethersproject/providers").Resolver | null>;
            _getResolver: (name: string, operation?: string | undefined) => Promise<string>;
            resolveName: (name: string | Promise<string>) => Promise<string | null>;
            lookupAddress: (address: string | Promise<string>) => Promise<string | null>;
            getAvatar: (nameOrAddress: string) => Promise<string | null>;
            _addEventListener: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean) => import("@ethersproject/providers").JsonRpcProvider;
            on: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/providers").JsonRpcProvider;
            once: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/providers").JsonRpcProvider;
            emit: (eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]) => boolean;
            listenerCount: (eventName?: import("@ethersproject/abstract-provider").EventType | undefined) => number;
            listeners: (eventName?: import("@ethersproject/abstract-provider").EventType | undefined) => import("@ethersproject/abstract-provider").Listener[];
            off: (eventName: import("@ethersproject/abstract-provider").EventType, listener?: import("@ethersproject/abstract-provider").Listener | undefined) => import("@ethersproject/providers").JsonRpcProvider;
            removeAllListeners: (eventName?: import("@ethersproject/abstract-provider").EventType | undefined) => import("@ethersproject/providers").JsonRpcProvider;
            getFeeData: () => Promise<import("@ethersproject/abstract-provider").FeeData>;
            addListener: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/abstract-provider").Provider;
            removeListener: (eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener) => import("@ethersproject/abstract-provider").Provider;
            readonly _isProvider: boolean;
        };
        _index: number;
        _address: string;
        connect: (provider: import("@ethersproject/abstract-provider").Provider) => import("@ethersproject/providers").JsonRpcSigner;
        connectUnchecked: () => import("@ethersproject/providers").JsonRpcSigner;
        getAddress: () => Promise<string>;
        sendUncheckedTransaction: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<string>;
        signTransaction: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<string>;
        sendTransaction: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        signMessage: (message: string | import("ethers").Bytes) => Promise<string>;
        _legacySignMessage: (message: string | import("ethers").Bytes) => Promise<string>;
        _signTypedData: (domain: import("ethers").TypedDataDomain, types: Record<string, import("ethers").TypedDataField[]>, value: Record<string, any>) => Promise<string>;
        unlock: (password: string) => Promise<boolean>;
        readonly _isSigner: boolean;
        getBalance: (blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined) => Promise<import("ethers").BigNumber>;
        getTransactionCount: (blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined) => Promise<number>;
        estimateGas: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<import("ethers").BigNumber>;
        call: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>, blockTag?: import("@ethersproject/abstract-provider").BlockTag | undefined) => Promise<string>;
        getChainId: () => Promise<number>;
        getGasPrice: () => Promise<import("ethers").BigNumber>;
        getFeeData: () => Promise<import("@ethersproject/abstract-provider").FeeData>;
        resolveName: (name: string) => Promise<string>;
        checkTransaction: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>;
        populateTransaction: (transaction: import("@ethersproject/properties").Deferrable<import("@ethersproject/abstract-provider").TransactionRequest>) => Promise<import("@ethersproject/abstract-provider").TransactionRequest>;
        _checkProvider: (operation?: string | undefined) => void;
    } | undefined>;
};
export declare function useDisconnect(): {
    disconnect: () => Promise<void>;
};
export declare function useWeb3ModalAccount(): {
    address: import("vue").Ref<`0x${string}` | undefined>;
    isConnected: import("vue").Ref<boolean>;
    chainId: import("vue").Ref<number | undefined>;
};
export { useWeb3ModalTheme, useWeb3Modal, useWeb3ModalState, useWeb3ModalEvents } from '@web3modal/scaffold-vue';
export { defaultConfig } from '../src/utils/defaultConfig.js';
